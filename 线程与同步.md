# 线程
c++11后的线程库是<thread>,不需要使用老的<pthread>

## 构造函数
* thread() noexcept：默认构造函数，创建一个空的thread执行对象；
* explicit thread(Fn&&fn, Args&&...args)：初始化构造函数，创建一个带函数调用参数的thread，这个线程是可joinable的；
* thread(const thread&) = delete：拷贝构造函数被禁用，意味着thread对象不可拷贝构造；
* thread(thread&& x) noexcept：移动构造函数，调用成功之后，x不代表任何thread执行对象；

## 生命周期
* join()是等待子线程执行完成之后，主线程才继续执行，此时主线程会释放掉执行完成后的子线程的资源。
* detach()将子线程从主线程中分离出来，这样主线程就对子线程没有控制权了，子线程执行完成后会自己释放掉资源。

linux上编译需要加上 -pthread,window,mac上不用

	#include <iostream>
	#include <thread>
	#include <string>
	#include <chrono>
	
	using namespace std;
	
	void thread_one()
	{
	    puts("hello");
	}
	
	void thread_two(int num, string& str)
	{
	    cout << "num:" << num << ",name:" << str << endl;
	}
	void f1(int n)
	{
	    for (int i = 0; i < 5; ++i)
	    {
		cout << "=====Thread:" << n << "======" << endl;
		this_thread::sleep_for(chrono::microseconds(10));
	    }
	}
	
	void f2(int& n)
	{
	    for (int i = 0; i < 5; ++i)
	    {
		cout << "thread two executing" << endl;
		++n;
		this_thread::sleep_for(chrono::microseconds(10));
	    }
	}
	int main(int argc, char* argv[])
	{
	    thread tt(thread_one);
	    tt.join();
	    string str = "luckin";
	    thread yy(thread_two, 88, ref(str));   //这里要注意是以引用的方式调用参数
	    yy.detach();
	
	    int n = 0;
	    thread t1;    //这是一个空的线程对象，还不是一个线程
	    thread t2(f1, n + 1);
	    thread t3(f2, ref(n));
	    thread t4(move(t3));    //t3不再是一个线程
	    t2.join();
	    t4.join();
	    cout << "the result n is:" << n << endl;
	    system("pause");
	    return 0;
	}


## 多线程开发
### mutex互斥量
* lock：锁定，锁已经被其他线程获得时则阻塞执行
* try_lock：尝试锁定，获得锁返回 true，在锁被其他线程获得时返回 false
* unlock：解除锁定（只允许在已获得锁时调用）


	#include <chrono>
	#include <iostream>
	#include <mutex>
	#include <thread>
	
	using namespace std;
	
	mutex output_lock;
	
	void func(const char* name)
	{
	  this_thread::sleep_for(100ms);
	  lock_guard<mutex> guard{
	    output_lock};
	  cout << "I am thread " << name
	       << '\n';
	}
	
	
	class scoped_thread {
	public:
	  template <typename... Arg>
	  scoped_thread(Arg&&... arg)
	    : thread_(
	        std::forward<Arg>(arg)...)
	  {}
	  scoped_thread(
	    scoped_thread&& other)
	    : thread_(
	        std::move(other.thread_))
	  {}
	  scoped_thread(
	    const scoped_thread&) = delete;
	  ~scoped_thread()
	  {
	    if (thread_.joinable()) {
	      thread_.join();
	    }
	  }
	
	private:
	  thread thread_;
	};
	
	
	
	int main()
	{
	  scoped_thread t1{func, "A"};
	  scoped_thread t2{func, "B"};
	}

### 其他互斥量
* recursive_mutex：在同一线程对同一个互斥量多次加锁 
* timed_mutex：允许锁定超时的互斥量
* recursive_timed_mutex：允许锁定超时的递归互斥量
* shared_mutex：允许共享和独占两种获得方式的互斥量
* shared_timed_mutex：允许共享和独占两种获得方式的、允许锁定超时的互斥量


### condition_variable 条件变量

	#include <chrono>
	#include <condition_variable>
	#include <functional>
	#include <iostream>
	#include <mutex>
	#include <thread>
	#include <utility>
	
	using namespace std;
	
	class scoped_thread {
	public:
	  template <typename... Arg>
	  scoped_thread(Arg&&... arg)
	    : thread_(
	        std::forward<Arg>(arg)...)
	  {}
	  scoped_thread(
	    scoped_thread&& other)
	    : thread_(
	        std::move(other.thread_))
	  {}
	  scoped_thread(
	    const scoped_thread&) = delete;
	  ~scoped_thread()
	  {
	    if (thread_.joinable()) {
	      thread_.join();
	    }
	  }
	
	private:
	  thread thread_;
	};
	
	void work(condition_variable& cv,
	          int& result)
	{
	  // 假装我们计算了很久
	  this_thread::sleep_for(2s);
	  result = 42;
	  cv.notify_one();
	}
	
	int main()
	{
	  condition_variable cv;
	  mutex cv_mut;
	  int result;
	
	  scoped_thread th{work, ref(cv),
	                   ref(result)};
	  // 干一些其他事
	  cout << "I am waiting now\n";
	  unique_lock lock{cv_mut};
	  cv.wait(lock);
	  cout << "Answer: " << result
	       << '\n';
	}

### future

一个 future 上只能调用一次 get 函数，第二次调用为未定义行为，通常导致程序崩溃（对于值类型的结果，get 会以移动的方式来返回）。这样一来，自然一个 future 是不能直接在多个线程里用的。


	#include <chrono>
	#include <future>
	#include <iostream>
	#include <thread>
	
	using namespace std;
	
	int work()
	{
	  // 假装我们计算了很久
	  this_thread::sleep_for(2s);
	  return 42;
	}
	
	int main()
	{
	  auto fut = async(launch::async, work);
	  // 干一些其他事
	  cout << "I am waiting now\n";
	  cout << "Answer: " << fut.get()
	       << '\n';
	}


### promise
promise 和 future 在这里成对出现，可以看作是一个一次性管道：有人需要兑现承诺，往 promise 里放东西（set_value）；有人就像收期货一样，到时间去 future就行了。我们把 prom 移动给新线程，这样老线程就完全不需要管理它的生命周期了。


	#include <chrono>
	#include <future>
	#include <iostream>
	#include <thread>
	#include <utility>
	
	using namespace std;
	
	class scoped_thread {
	public:
	  template <typename... Arg>
	  scoped_thread(Arg&&... arg)
	    : thread_(
	        std::forward<Arg>(arg)...)
	  {}
	  scoped_thread(
	    scoped_thread&& other)
	    : thread_(
	        std::move(other.thread_))
	  {}
	  scoped_thread(
	    const scoped_thread&) = delete;
	  ~scoped_thread()
	  {
	    if (thread_.joinable()) {
	      thread_.join();
	    }
	  }
	
	private:
	  thread thread_;
	};
	
	void work(promise<int> prom)
	{
	  // 假装我们计算了很久
	  this_thread::sleep_for(2s);
	  prom.set_value(42);
	}
	
	int main()
	{
	  promise<int> prom;
	  auto fut = prom.get_future();
	  scoped_thread th{work,
	                   move(prom)};
	  // 干一些其他事
	  cout << "I am waiting now\n";
	  cout << "Answer: " << fut.get()
	       << '\n';
	}

